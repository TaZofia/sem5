\documentclass{article}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{booktabs}

\setlength{\parindent}{0pt}

\title{Sprawozdanie laboratorium lista 5 \\Obliczenia naukowe}
\author{\normalsize Zofia Tarchalska, indeks: 279699}
\date{}

\begin{document}
\maketitle
\section{Wstęp}
Celem tej listy było zaimplementowanie trzech poniższych algorytmów o złożoności $O(n)$, gdzie $n$ to rozmiar macierzy $n \times n$.
\begin{itemize}
    \item funkcja rozwiązująca układ $Ax=b$ metodą eliminacji Gaussa
    \item funkcja wyznaczająca rozkład $LU$ maciezry $A$ metodą eliminacji Gaussa
    \item funkcja rozwiązująca układ $Ax=b$ jeśli już wcześniej został wyznaczony rozkład $LU$
\end{itemize}
Wszystkie te algorytmy mają działać dla macierzy $A$ o specyficznej postaci, która została dokładnie opisana w poleceniu do zadania. Dodatkowo należało zaprogramować wersję podstawową oraz wersję z wybieraniem elementu głównego.

\section{Metoda eliminacji Gaussa}
Główną ideą metody eliminacji Gaussa jest doprowadzenie macierzy do postaci, w której pod przekątną znajdują się same zera. Uzyskujemy to poprzez mnożenie kolejnych wierszy macierzy przez odpowiednie czynniki i odejmowanie ich od wierszy następujących po nich. Poprawny schemat:


Eliminujemy zmienną $x_k$ z wierszy od $k + 1$ do $n$. Mnożymy $k-te$ równanie przez 
\[
    l_{ik} = \frac{a_{ik}}{a_{kk}} \quad \text{dla } i \in \{k + 1, ..., n\}
\]

Kiedy jednak na przekątnej w miejscu $a_{kk}$ będzie $0$ metoda może powodować błąd numeryczny, ponieważ nastąpi dzielenie przez $0$. W przeciwnym wypadku, po wykonaniu odpowiednich kroków kolejno dla wszystkich wierszy macierzy, otrzymujemy macierz górnotrójkątną. 

\subsection{Wariant pierwszy - bez wyboru elementu głównego}
Ten wariant nie zabezpiecza nas przed opisanym powyżej błędem numerycznym.

\subsubsection{Złożoność czasowa}
W niezoptymalizowanej wersji algorytmu złożoność wynosiłaby $O(n^3)$, ponieważ mamy 3 pętle \texttt{for} przechodzące po elementach macierzy. Dla każdego wiersza w macierzy wyznaczamy czynnik przez który przemnażamy ten wiersz po czym odejmujemy go od kolejnych wierszy (musimy przejść po wszytskich elementach w danym wierszu, a macierz ma wymiary $n \times n$). Jednak wykorzystując blokową strukturę macierzy A da się sprowadzić ten algorytm do złożoności $O(n)$. Wiemy, że rozmiar pojedynczego bloku ma jakiś określony rozmiar. Oznaczmy go przez l. Zatem pod przekątną macierzy jest maksymalnie l elementów, które są niezerowe. Dodatkowo każdy wiersz, o indeksie większym niż 1 ma od lewej same zera, następnie l leżących po sobie niezerowych wartości i znów zera (chyba, że np. $k+l$ daje już indeks ostatniej kolumny, wtedy nie ma zar od końca). Możemy zatem wykonywać ten algorytm tylko dla wierszy i elementów, dla których ma to sens (oszczędzimy sobie przetwarzania ogromnej liczby samych zer). Możemy zatem odejmować tylko l wierszy i aktualizować w nich l wartości. Ponieważ l jest znacząco mniejsze niż n, złożoność spada do $O(n)$.

\subsubsection{Złożoność pamięciowa}
Zaimplementowana przeze mnie struktura \texttt{BlockMatrix} przechowuje naszą macierz blokową A. Korzysta przy tym ze \texttt{SparseArrays} dostępnych w języku Julia. \texttt{SparseArrays} nie przechowują niezerowych elementów, wobec tego, ze względu na budowę A, mamy tylko elementy zlokalizowane w otoczeniu przekątnej. Ponieważ jest to co najwyżej l elementów przypadających na każdy wiersz/kolumnę, których jest n, to ze względu, że l jest jakąś stałą, złożoność pamięciowa to $O(n)$.

\subsubsection{Pseudokod}
Każde wykonanaie pętli \texttt{for} jest ograniczone do pewnych indeksów, dla których występują niezerowe elementy. Dzięki temu dokonujemy optymalizowania opisanego we wcześniejszym paragrafie i ograniczamy nasze obliczenia tylko do tyxh elementów, które mają rzeczywisty wpływ na wynik.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Procedure{GaussElimination}{$A,\; b$}
  \State $n \gets \text{size}(A)$
  \For{$k \gets 1$ to $n-1$}
    \For{$i \gets k+1$ to $min(n, k + A.blockSize + 1)$}
      \State \text{Jeżeli A[k, k] jest zerem - błąd}
      \State $m \gets A[i,k] / A[k,k]$
      \State $A[i,k] \gets 0$
      \For{$j \gets k+1$ to $min(n, k + A.blockSize + 1)$}
        \State $A[i,j] \gets A[i,j] - m \cdot A[k,j]$
      \EndFor
      \State $b[i] \gets b[i] - m \cdot b[k]$
    \EndFor
  \EndFor

  \State $x \gets \mathbf{0}\in\mathbb{R}^n$
  \State $x[n] \gets b[n] / A[n,n]$
  \For{$i \gets n-1$ \textbf{downto} $1$}
    \State $s \gets 0$
    \For{$j \gets i+1$ to $min(n, i + 2 \cdot A.blockSize)$}
      \State $s \gets s + A[i,j]\cdot x[j]$
    \EndFor
    \State $x[i] \gets (b[i] - s) / A[i,i]$
  \EndFor
  \State \Return $x$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Wariant drugi - z częściowym wyborem \\elementu głównego}
Ten wariant ma zabezpieczać nas przed potencjalnym dzieleniem przez $0$ gdy na przekątnej macierzy taka warotść się znajduje. Biorąc pod uwagę, że obliczenia wykonujemy na komputerze, liczby bardzo zbliżone do $0$ również są tymi, które mogą nam zwrócić błąd.

Element główny to nic innego jak wybrana wartość, którą będziemy używać aby wyzerować pozostałe w kolumnie. Wybieramy ją poprzez znaleznienie największej wartości w kolumnie (patrząc na jej moduł). Następnie wyznaczamy czynnik, przez który będziemy mnożyć kolejne wiersze, korzystając już z tej największej wartości. Zapamiętujemy, które wiersze zostały zamienione za pomocą tablicy permutacji. Dzięki temu nie modyfikujemy macierzy A, a odwołując się do konkretnego wiersza zamiast używać jego indeksu wprost, używamy \texttt{p[indeks]}. 

\subsubsection{Złożoność czasowa}
Algorytm z wyborem elementu głównego jest bardzo podobny do zwykłej eliminacji Gaussa. Jedyna różnica polega na tym, że w pierwszej pętli \texttt{for} gdy przechodzimy po kolumnach wybieramy największą wartość w danej kolumnie. Następnie wykonujemy, tak samo, resztę algorytmu na zmienionej kolejności wierszy. Ta jedna dodatkowa pętla nawet w niezoptymalizowanej wersji nie zwiększyłaby złożoności algorytmu. Wobec tego pozostaje, identycznie jak poprzednio, złożność czasowa równa $O(n)$.
\subsubsection{Złożoność pamięciowa}
W tym algorytmie mamy dodatkową tablicę permutacji. Jest ona rozmiaru $n$, który odpowiada liczbie wierszy w macierzy. Poza nią wszystko jest przechowywane tak samo jak poprzednio. Czyli, wszystkie modyfikacje wykonywane są in-place na macierzy A. Jak już wspomniałam wcześniej tablica permutacji ma n elementów, a więc nie zmienia to rzędu pamięci. Wobec tego złożoność pamięciowa to dalej $O(n)$.

\subsubsection{Pseudokod}
\begin{algorithm}[H]
\begin{algorithmic}[1]
\Require $A$ -- \texttt{BlockMatrix} $n\times n$; $b$ -- wektor prawych stron dł. $n$
\Ensure $x$ -- rozwiązanie układu $Ax=b$
\State $n \gets A.size$
\State $p \gets [1,2,\dots,n]$ \Comment{wektor permutacji (mapowanie wierszy)}
\For{$k \gets 1$ \textbf{to} $n-1$}
    \State $bound \gets min(n, k + A.blockSize + 1)$
    \State $j \gets k$ \Comment{indeks wiersza z największym elementem w kolumnie}
    \State \text{Znajdź największy element w kolumnie i przypisz do j}
    \State swap($p[k], p[j]$) \Comment{zamiana w wektorze permutacji}
    \For{$i \gets k+1$ \textbf{to} $bound$}
        \State $z \gets A[p[i],k] / A[p[k],k]$
        \State $A[p[i],k] \gets 0$
        \For{$j \gets k+1$ \textbf{to} $min(n, k + 2 \cdot A.blockSize)$}
            \State $A[p[i],j] \gets A[p[i],j] - z \cdot A[p[k],j]$
        \EndFor
        \State $b[p[i]] \gets b[p[i]] - z \cdot b[p[k]]$
    \EndFor
\EndFor

\State $x \gets \mathbf{0}\in\mathbb{R}^n$
\State $x[n] \gets b[p[n]] / A[p[n],n]$
\For{$i \gets n-1$ \textbf{downto} $1$}
    \State $s \gets b[p[i]]$
    \State $last \gets \text{get\_last\_column}(A,\,i + A.block\_size)$
    \For{$j \gets i+1$ \textbf{to} $last$}
        \State $s \gets s - A[p[i],j] \cdot x[j]$
    \EndFor
    \State $x[i] \gets s / A[p[i],i]$
\EndFor

\State \Return $x$
\end{algorithmic}
\end{algorithm}


\section{Rozkład LU}
Rozkład LU to taki podział, w którym A = LU. Czyli zamieniamy macierz A na dwie macierze trójkątne. L jest macierzą dolnotrójkątną, a U górnotrójkątną. L zawiera mnożniki $l_{ik}$ w miejscu zerowanych elementów. 


\[
L =
\begin{pmatrix}
1        & \cdots  &        &        & 1      \\
m_{21}   & 1       & \cdots &        &        \\
m_{31}   & m_{32}  & 1      & \cdots &        \\
\vdots   & \vdots  & \ddots & \ddots & \vdots \\
m_{n1}   & m_{n2}  & \cdots & m_{n,n-1} & 1
\end{pmatrix}
\]

\[
U =
\begin{pmatrix}
u_{11} & u_{12} & \cdots & u_{1n} \\
0      & u_{22} & \cdots & u_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
0      & 0      & \cdots & u_{nn}
\end{pmatrix}
\]\\

Znając LU sprowadzamy nasz problem do rozwiązania
\[
Ly = b
\]
\[
Ux = y
\]

Podczas obliczeń, aby odszczędzać miejsce, będziemy modyfikować macierz A, tak aby pod przekątną znalazło się L a pozostałe miejsca były zajęte przez U.

\subsection{Wariant pierwszy - bez wyboru elementu głównego}

\subsubsection{Złożoność czasowa}
Po przyjrzeniu się algorytmowi na wyznaczenie LU zauważymy, że jest on bardzo podobny do procesu eliminacji w eliminacji Gaussa. Występują dokładnie te same obliczenia z tą różnicą, że macierz A jest modyfikowana i zapisywane są wewnątrz niej wartości L oraz U. Z tego powodu możemy stwierdzić, że złożoność czasowa tego algorytmu to również $O(n)$.

\subsubsection{Złożoność pamięciowa}
Jeśli chodzi o złożoność pamięciową to LU zapisujemy w A. Obydwie macierze mają tą samą strukturę. Więc złożoność pamięciowa wynosi $O(n)$.


\subsubsection{Pseudokody}
\begin{algorithm}[H]
\caption{Generowanie rozkładu LU (in‑place)}
\begin{algorithmic}[1]
\Require $A$ -- macierz $n\times n$ typu BlockMatrix
\Ensure macierz $A$ zmodyfikowana tak, że dolna część zawiera współczynniki $L$, a górna część zawiera $U$
\State $n \gets A.size$
\For{$k \gets 1$ \textbf{to} $n-1$}
  \For{$i \gets k+1$ \textbf{to} $min(n, k + A.blockSize + 1)$}
    \State \text{Jeżeli A[k, k] jest zerem - błąd}
    \State $l \gets A[i,k] / A[k,k]$ \Comment{współczynnik L}
    \State $A[i,k] \gets l$ \Comment{zapisujemy $l$ w dolnej części}
    \For{$j \gets k+1$ \textbf{to} $min(n, k + A.blockSize + 1)$}
      \State $A[i,j] \gets A[i,j] - l \cdot A[k,j]$ \Comment{aktualizacja elementów U}
    \EndFor
  \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Rozwiązywanie układu przy użyciu rozkładu LU (in‑place)}
\begin{algorithmic}[1]
\Require $LU$ -- macierz zawierająca $L$ (pod przekątną) i $U$ (nad przekątną)
\Require $b$ -- wektor prawych stron długości $n$ (nadpisywany)
\Ensure $x$ -- rozwiązanie układu $Ax=b$
\State $n \gets LU.size$
\Comment{1. Rozwiązanie $L y = b$ (podstawianie w przód), wynik zapisany w $b$}
\For{$k \gets 1$ \textbf{to} $n-1$}
  \For{$i \gets k+1$ \textbf{to} $min(n , k + LU.blockSize + 1)$}
    \State $b[i] \gets b[i] - LU[i,k]\cdot b[k]$
  \EndFor
\EndFor

\Comment{2. Rozwiązanie $U x = y$ (podstawianie wsteczne)}
\State $x \gets \mathbf{0}\in\mathbb{R}^n$
\For{$i \gets n$ \textbf{downto} $1$}
  \State $s \gets b[i]$
  \For{$j \gets i+1$ \textbf{to} $min(n , i + LU.blockSize)$}
    \State $s \gets s - LU[i,j]\cdot x[j]$
  \EndFor
  \State $x[i] \gets s / LU[i,i]$
\EndFor

\State \Return $x$
\end{algorithmic}
\end{algorithm}


\subsection{Wariant drugi - z częciowym wyborem \\elementu głównego}
Analogicznie jak w przypadku eliminacji Gaussa z częściowym wyborem, ten wariant zapobiega błędom numerycznym w przypadku bliskim lub równym zera wartościom na przekątnej macierzy A. Lekko modyfikujemy podstawowy algorytm wyznaczania rozkładu LU, zamieniając wiersze miejscami i zapamiętując tablicę permutacji. W tym samym momencie odpowiednio modyfikujemy macierz A tworząc z niej macierz LU.

\subsubsection{Złożoność czasowa}
W tym algorytmie występuje taka sama pętla \texttt{for}, odpowiedzialna za szukanie największego elementu w kolumnie, jak w wypadku eliminacji Gaussa z częściowym wyborem elementu głównego. Następnie algorytm wyznaczania rozkłau LU wygląda niemal identycznie jak faza eliminacji z tą różnicą, że macierz A jest wtedy odpowiednio modyfikowana. Wobec tego złożoność czasowa algorytmu to $O(n)$.

\subsubsection{Złożoność pamięciowa}
Uzasadnienie, że złożoność pamięciowa algorytmu wynosi $O(n)$ nasuwa się samo. Skoro dominującym czynnikiem jest tu macierz A, którą modyfikujemy in-place i w żadnym momencie nie potrzebujemy tworzenia dodatkowej kopii (z wyjątkiem macierzy permutacji, ale zostało już wytłumaczone dlaczego nie jest to problemem) albo nowej struktury to złożoność wynosi $O(n)$.

\section{Eksperymenty}





\end{document}